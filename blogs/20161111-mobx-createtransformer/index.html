<html><head><link href="https://fonts.googleapis.com/css?family=Droid+Sans|Droid+Sans+Mono|Droid+Serif" rel="stylesheet"/><link rel="stylesheet" type="text/css" href="/app.css"/></head><body style="margin:0;"><div class="_2FE2Ol8dGrN-YlQ4B4fd40"><div class=""><div><div class="_3MqAN7tezej4SSAbTmSEU0"><div class="_2A9JiSIm3an8uWVyKeaP9N">uweg.github.io</div><div class="_2qUWYN3yxUrcdowGt6joVI"><div>welcome to my website!</div><hr style="margin-top:20px;"/><div>This website is to write down my ideas and solutions for problems I had. I make it public because maybe someone else will find something useful. Also, of course, it is a little playground for me to test the latest frameworks and stuff. Feel free to contact me, if you want to discuss a topic in greater depth.</div></div></div><hr/></div><div><div class="_3VsiRofGuWR73_fOfHb0RE"><a href="/blogs/20161111-mobx-createtransformer">/blogs/20161111-mobx-createtransformer</a><div class="_3uxHLI_NTcR3_FAO-2OItJ">November 11, 2016</div><div class="_34oSE90yaq6CDdZ4hqdJXz"><h1 id="mobx-createtransformer">MobX createTransformer</h1>
<p>The <a href="http://mobxjs.github.io/mobx/refguide/create-transformer.html"><code>createTransformer</code></a> functionality in the MobX framework was something i struggled a bit to understand until now. This blog post should finally help me to get a grasp of it.</p>
<p>This functionality can be used to store the result of a transformation of an observable an then server this stored value until the observable has changed.</p>
<p>It also can be used to transform one tree of observable objects into another tree of observable objects. This reminds me a little bit of <a href="http://redux.js.org/">Redux</a>, another very popular state handling library for React.</p>
<p>I created a very simple example to show the basic functionality of it:</p>
<pre><code class="lang-typescript">const observableValue = observable(3);

const transformer = createTransformer&lt;IObservableValue&lt;number&gt;, number&gt;((value) =&gt; {
  console.log(&#39;Transformer evaluated.&#39;);
  return observableValue.get() * 2;
});

autorun(() =&gt; {
  console.log(transformer(observableValue));
  console.log(transformer(observableValue));
});

observableValue.set(4);
</code></pre>
<p>When i run it, the console output is:</p>
<pre><code>Transformer evaluated.
6
6
Transformer evaluated.
8
8
</code></pre><p><code>transformer</code> will only be re-evaluated when the underlying observable changes. of course, this example is very trivial but the mechanism is very powerful to create more complex things without losing more performance as needed.</p>
</div></div><hr/></div></div></div></body></html>